
-------------------------------------------------------------------------------

-- 1. Какие из выражений ниже находятся в слабой головной нормальной форме (WHNF),
--    но не в номальной форме (NF)? Почему? (1,5 балла)

-- Подсказка: выражение undefined находится не в NF:
--            оно может быть вычислено до прерывания программы с сообщением "*** Exception: Prelude.undefined"

    -- (+) (2 * 3 * 4)
{-
Находится в WHNF, так как это вычесленный конструктор +.
-}
    -- [undefined, 4 + 5, -1]
{-
Находится в WHNF, аналогично предыдущему пунтку для конструктора undefined.
-}
    -- (,) undefined
{-
Находится в WHNF, аналогично, конструктор (,).
-}
    -- 3
{-
В NF, так как это значение уже полностью вычислено.
-}
    -- fst (1,0)
{-
Не WHNF и не NF, потому что еще не выполнено само применение fst.
-}
    -- \x -> x
{-
В WHNF, так как это лямбда-выражение.
-}
-------------------------------------------------------------------------------

-- 2. Распишите вычисление `value` в thunk'ах (1 балл)

value :: Integer
value = foo (3 * 10) (5 - 2)
  where
    foo :: Num p => p -> p -> p
    foo a b = bar a a (a + b)

    bar :: Num a => a -> a -> p -> a
    bar x y z = x + y

-- <thunk: foo (3 * 10) (5 - 2)>

-- <thunk: bar (3 * 10) (3 * 10) ((3 * 10) + (5 - 2))>

-- <thunk: (3 * 10) + (3 * 10)>

-- <thunk: (30) + (30)>

-- <thunk: 60>
-- 60

-------------------------------------------------------------------------------

-- 3. Какие из нижеперечисленных функций не могут привести к расходимости (неостановке вычисления)? Почему? (2 балла)

wow :: p -> p
wow a = a
{-
Может привести к расходимости если подать бесконечный список
-}
con :: b -> Integer -> Integer -> Integer
con = const foo
{-
может уйти в бесконечную рекурсию, если аргумент отрицательный
-}
bazz :: p -> b -> Bool
bazz x = const True
{-
Не вызовет расходимость, так как она всегда возвращает True независимо от своих аргументов.
-}
qux :: t
qux = let x = x in x
{-
Вызовет расходимость. Это бесконечное рекурсивное определение, которое не завершится.
-}
corge :: String
corge = "Sorry, my value was changed"
{-
Не вызовет расходимость. Это константное значение.
-}
grault :: (Eq a, Num a) => p -> a -> p
grault x 0 = x
grault x y = x
{-
Может привести к расходимости, если вместо x подать бесконечный список
-}
garply :: Integer -> Char
garply = grault 'q'
{-
Не вызовет расходимость. Она просто вызывает grault 'q', что является безопасным вызовом функции grault.
-}
waldo :: Integer -> Integer -> Integer
waldo = foo
{-
может привести к расходимости, если первый аргумент отрицательный
-}
-------------------------------------------------------------------------------

-- 4. BangPatterns  (0,5 балла)
--    Реализуйте `foldl'`, форсировав вычисление с помощью ! аналогично `sumBang` из лекции
{-# LANGUAGE BangPatterns #-}

foldl' :: (b -> a -> b) -> b -> [a] -> b
foldl' _ acc []     = acc
foldl' f !acc (x:xs) = foldl' f (f acc x) xs

result :: Integer
result = foldl' (\acc x -> acc + x*x) 0 [1..5]
-------------------------------------------------------------------------------

-- 5. `seq` (2 балла)

-- Помимо ! есть и другие способы форсировать вычисление.
-- Например, если вы хотите вычислить значение перед передачей его в функцию, можно использовать `seq` 
-- https://hackage.haskell.org/package/ghc-prim-0.11.0/docs/GHC-Prim.html#v:seq

-- `seq` принимает 2 аргумента, вычисляет первый до WHNF и возвращает второй

-- Как использовать? Пример с foldl':
-- https://hackage.haskell.org/package/base-4.19.0.0/docs/src/Data.Foldable.html#foldl%27
-- Здесь есть следующий код: z `seq` k (f z x).
-- В этом случае первый аргумент `seq` -- z, и z будет вычислено до WHNF,
-- а затем он будет использоватся при вычислении второго аргумента -- k (f z x).
-- Результат вычисления второго аргумента -- результат всего `seq`

-- Практикуемся: rде поможет seq?
-- При вычислении каких из перечисленных ниже функций использование seq предотвратит
-- нарастание количества невычисленных выражений при увеличении значения первого аргумента?
-- Объясните свой ответ

foo :: (Eq a, Num a, Num t) => a -> t -> t
foo 0 x = x
foo n x = let x' = foo (n - 1) (x + 1)
          in x' `seq` x'
{-
В данной функции использование seq перед x' не имеет смысла. 
Это потому, что x' уже включает в себя результат вычисления foo (n - 1) (x + 1). seq примененный к x' не изменит процесс вычисления, так как x' уже будет полностью вычислено до WHNF.
-}
bar :: (Eq t1, Num t1) => t1 -> (t1 -> t2) -> t1 -> t2
bar 0 f = f
bar x f = let f' = \a -> f (x + a)
              x' = x - 1
          in f' `seq` x' `seq` bar x' f'
{-
В этой функции seq перед f' и x' имеет смысл. Он заставляет вычислить f' и x' до WHNF, прежде чем продолжить вычисление. Это может предотвратить накопление отложенных вычислений.
-}
baz :: (Eq t, Num t, Num a) => t -> (a, a) -> a
baz 0 (x, y) = x + y
baz n (x, y) = let x' = x + 1
                   y' = y - 1
                   p  = (x', y')
                   n' = n - 1
               in p `seq` n' `seq` baz n' p
{-
В данной функции использование seq перед p и n' имеет смысл. Это может предотвратить накопление отложенных вычислений, так как p зависит от (x', y'), и n' зависит от n - 1.
-}
quux :: (Eq t, Num t, Num a) => t -> (a, a) -> a
quux 0 (x, y) = x + y
quux n (x, y) = let x' = x + 1
                    y' = y - 1
                    p  = (x', y')
                    n' = n - 1
                in x' `seq` y' `seq` n' `seq` quux n' p
{-
В данной функции использование seq перед x', y' и n' имеет смысл. Это может предотвратить накопление отложенных вычислений, так как x', y' и n' зависят от предыдущих вычислений.
-}
-------------------------------------------------------------------------------

-- 6. $! (1 балл)

-- Вдобавок к ! и `seq` есть $!. Он нужен, чтобы вычислить значение перед передачей его в функцию.
-- Несложно заметить, что он напоминает $ -- оператор применения.
-- $! -- строгую версию $, вычисляющую аргумент до WHNF перед передачей его в функцию

-- Ниже определены функции mySum и goSum. Ответьте на вопросы об их вычислении

mySum :: (Eq a, Num a) => (a, ()) -> a -> (a, ())
mySum acc 0 = acc
-- 6.a Почему Haskell говорит здесь, что $! -- redundant?
mySum (result, ()) n = (mySum $! (result + n, ())) $ n - 1

goSum :: Integer -> (Integer, ())
goSum = mySum (0, ())
{-
Haskell указывает, что $! является избыточным, потому что в данном случае $! не предоставляет дополнительной выгоды. 
Это происходит потому, что второй аргумент mySum уже является значением типа (), который является типом данных с единственным конструктором, не имеющим полей. 
Таким образом, этот аргумент не может быть ленивым, и использование $! не приводит к дополнительной строгости в данном случае.
-}

-- 6.b Будут ли накапливаться отложенные вычисления в первом аргументе функции mySum?
--    Да или нет и почему?
{-
В данной рекурсивной функции mySum, накопление отложенных вычислений будет происходить в первом аргументе (result, ()). 
Это происходит из-за ленивости в Haskell. Вычисления будут отложены до момента, когда значение result будет фактически использовано, что произойдет при завершении рекурсии.
-}

-- 6.c Будут ли накапливаться отложенные вычисления во втором аргументе функции mySum?
--    Да или нет и почему?
{-
Нет, отложенные вычисления не будут накапливаться во втором аргументе mySum, поскольку тип () не имеет полей, 
и он уже полностью вычислен до WHNF (Weak Head Normal Form). Второй аргумент не зависит от предыдущих значений, и $! не влияет на его строгость в данном контексте.
-}
-------------------------------------------------------------------------------

-- 7*. Почему здесь происходит утечка памяти? Как ее исправить? (2 балла)

-- let small' = fst (small, large) in ... small' ...

{-

Проблема с утечкой памяти в этом коде связана с тем, что small' получает ссылку на кортеж (small, large). 
Поскольку small' зависит от обоих элементов кортежа, и ссылка на кортеж сохраняется в small', то оба элемента остаются в памяти, даже если small' использует только первый элемент.
Чтобы исправить утечку памяти, можно использовать функцию seq, чтобы вынудить вычисление small' и избежать сохранения ссылки на кортеж.

let !small' = fst (small, large) in ... small' ...

Используя ! перед small', мы применяем seq к результату fst, что приводит к тому, что значение small' вычисляется строго, и не сохраняется ссылка на кортеж.

-}
-------------------------------------------------------------------------------
