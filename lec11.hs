{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE MagicHash #-}
import GHC.Prim (Double#)

-------------------------------------------------------------------------------

-- Стратегии вычисления: call-by-need vs call-by-value

-- C++: call-by-value
-- Мы вычисляем аргументы функции полностью до ее вызова

-- int f(int x, int y) { 
--     if (x > 0) {
--       return x-1;
--     } else {
--       return x+1;
--     }
-- }

-- Haskell: call-by-need
f :: Int -> Int -> Int
f x y = if x > 0 then x - 1 else x + 1

f' :: Num a => a -> a
f' x = x - 1

-- вычислится!
callF :: Int
callF = f 1 (product [1..])

-- Различные стратегии вычисления: https://en.wikipedia.org/wiki/Evaluation_strategy

-------------------------------------------------------------------------------

-- Нормальная форма NF и слабая головная нормальная форма WHNF

length' :: [a] -> Int
length' l = go l 0
  where
    go []     acc = acc
    go (x:xs) acc = go xs (acc+1)

len3 :: Int
len3 = length' [1,2,3]

-- вычислится!
-- Почему? Нам же нужно было вычислить список, чтобы получить ответ
lenWithProd :: Int
lenWithProd = let x = product [1..] in length' [1, x]

-- GHC будет вычислять только то, что действительно необходимо

-- data [] a = [] | (:) a [a]
data List a = Cons a (List a) | Nil

-- length' [1, x]
-- = length' 1:(x:[])
-- = 1 + length' (x:[])
-- = 1 + 1 + length' []
-- = 1 + 1 + 0
-- = 2

-- Идея в том, что нам не нужно вычислять само значение x, чтобы вычислить длину списка,
-- поэтому на каждом шаге мы проверяем, пришел ли нам пустой список -- если нет, раскрываем его дальше,
-- но не вычисляем элементы

-- Увеличивает длину списка только, если элемент положителен
weirdLength :: [Int] -> Int
weirdLength []                 = 0                 
weirdLength (x:xs) | x < 0     = weirdLength xs
                   | otherwise = 1 + weirdLength xs

-- повисла :(
-- почему?
weirdLenWithProd :: Int
weirdLenWithProd = let x = product [1..] in weirdLength [1, x]

-- weirdLength [1, x]
-- = weirdLength 1:(x:[])
-- = 1 + weirdLength (x:[])
-- = 1 + ???

-- аналогично с ADT -- Algebraic Data Types

isNothing :: Maybe Integer -> Bool
isNothing Nothing  = True
isNothing (Just x) = x == 0

boolList :: [Bool]
boolList = let x = product [1..] in [
    isNothing Nothing
  , isNothing (Just 4)
  , isNothing (Just x)]

-- Нормальная форма (NF):
-- Выражение в нормальной форме было полностью вычислено, нет ничего, что осталось бы невычисленным
-- 1
-- "haskell"
-- (2, True, Nothing)
-- \x -> x + 4
-- Maybe 23

-- Слабая головная нормальная форма (WHNF):
-- Либо лямбда-абстракция, либо выражение, у которого вычислен крайний конструктор,
-- но в остальном оно может содержать невычисленные подвыражения
-- (1+1, 2) - которое можно переписать как (,) (1+1) 2, поэтому крайним конструктором является (,)
-- Just (sum [1..10]) - крайним конструктором здесь является Just
-- 1 : computePrimesUpTo 100 - крайним конструктором здесь является (:)
-- \x -> 2+2 - абстракция лямбды, которая не требует сокращения тела

-------------------------------------------------------------------------------

-- thunks: Ленивость в GHC

-- GHC реализует лень с помощью thunks.
-- Вы можете представить себе thunk как коробку, содержащую некоторое выражение, которое еще не было вычислено.
-- Когда потребуется фактическое значение этого выражения, среда выполнения откроет thunk и вычислит то, что в нем находится.
-- Как только выражение будет вычислено (если оно завершится, то есть выдаст значение), GHC перезапишет thunk, заменив "указатель"
-- на выражение для вычисления фактическим результатом.

-- По умолчанию в (GHC) Haskell практически все создает thunk: это реализация нестрогости, как того требует Haskell report

negList :: [Integer]
negList = map negate [1,2,3]

-- map negate (1:2:3:[])
-- Первый шаг вычисления:
-- <thunk: map negate <thunk: (1:2:3:[])>>

-- map :: (a -> b) -> [a] -> [b]
-- map _ []     = []
-- map f (x:xs) = f x : map f xs

-- Второй шаг:
-- <thunk: negate <thunk: 1> : <thunk: map negate <thunk: [2,3]>>

-- negate x = -x

-- 3
-- -<thunk: 1> : <thunk: map negate <thunk: [2,3]>>

-- 4
-- -1 : <thunk: map negate <thunk: [2,3]>>

-- мы вычисляем [2,3] до WHNF, чтобы просто выяснить, что там со следующим выражением для map
-- -1 : <thunk: negate <thunk: 2>> : <thunk: map negate <thunk: [3]>>
-- -1 : -<thunk: 2> : <thunk: map negate <thunk: [3]>>
-- -1 : -2 : <thunk map negate <thunk: [3]>>
-- -1 : -2 : <thunk: negate <thunk: 3>> : <thunk: map negate <thunk: []>>
-- -1 : -2 -<thunk: 3> : <thunk: map negate <thunk: []>>
-- -1 : -2 : -3 : <thunk: map negate <thunk: []>>
-- -1 : -2 : -3 : []

-- теперь возьмем 6
take6 :: [Int]
take6 = take 6 $ map negate [1..]

-- take :: Int -> [a] -> [a]
-- take n _ | n <= 0 = []
-- take _ [] = []
-- take n (x:xs) = x : take (n-1) xs

-- Важно помнить: Вычисление начинается с самого внешнего выражения!

-- Добиться максимальной производительности от вашего кода на Haskell -- адаптировать вычисление ваших данных
-- к конкретному способу их использования в вашем случае. Если вы читаете много данных из файла и обрабатываете
-- скажем, каждую строку отдельно, то хорошей идеей будет НЕ читать весь файл сразу в памяти.
-- Хорошая реализация будет считывать данные и выдавать список строк "по требованию".
-- Затем функция, обрабатывающая каждую строку, будет принимать этот список в качестве аргумента и потреблять
-- его по мере создания, выполняя обработку с O(1) использованием пространства.

-------------------------------------------------------------------------------

-- (не) Строгость

sum' :: Num a => [a] -> a
sum' []     = 0
sum' (x:xs) = x + sum' xs

-- sum [1..5]
-- = sum (1:2:3:4:5:[])                
-- = 1 + sum (2:3:4:5:[])               
-- = 1 + (2 + sum (3:4:5[]))            
-- = ...
-- = 1 + (2 + (3 + (4 + (5 + sum []))))
-- = 1 + (2 + (3 + (4 + (5 + 0     ))))
-- = 15

-- Теперь обратите внимание, как накапливаются дополнения, которые на самом деле не вычисляются.
-- Это происходит потому, что sum накапливает несколько thunks по мере обхода списка.
-- Очевидно, что мы хотим вычислять результат по мере обхода списка.
-- Возможно, мы могли бы использовать вспомогательную функцию с аккумулятором, верно?

sumTail :: Num a => [a] -> a
sumTail xs = go xs 0
  where
    go []     acc = acc
    go (x:xs) acc = go xs (acc + x)

-- sum [1..5]
-- = go [1..5] 0
-- = go [2..5] (0+1)         
-- = go [3..5] (0+1+2)       
-- = go [4,5]  (0+1+2+3)     
-- = go [5]    (0+1+2+3+4)   
-- = go []     (0+1+2+3+4+5)
-- = 0+1+2+3+4+5
-- = 15

-- Прибавления снова накапливаются! Как мы можем избежать этого?

-------------------------------------------------------------------------------

-- Bang!

-- BangPatterns расширение

sumBang :: Num a => [a] -> a
sumBang xs = go xs 0
  where
    go []     !acc = acc
    go (x:xs) !acc = go xs (acc + x)

-- sum [1..5]
-- = go [1..5] 0
-- = go [2..5] 1
-- = go [3..5] 3
-- = go [4,5]  6
-- = go [5]    10
-- = go []     15
-- = 15

-- ! заставляет вычислять аргумент до WHNF -- ок для чисел, но не списка или Maybe Int (почему?)

-------------------------------------------------------------------------------

-- Строгое вычисление полей

-- Представьте, что вы выполняете кучу матричных/векторных операций
-- (например, именно это нужно делать при реализации алгоритма обучения обратного распространения ошибки)
-- Мы не хотим, чтобы операции накапливались до того, как они будут вычислены!
-- Это означало бы, что тысячи и тысячи арифметических операций должны были бы быть выполнены практически за один раз в конце,
-- чтобы вычислить новые матрицы, выход нейронной сети по всем входным векторам и так далее.
-- Нам нужно как-то заставить вычислять все наши матрицы и векторные коэффициенты сразу же, но накидывать на наш код кучу bang'ов
-- Есть способ получше

-- 2x2 matrix
data Matrix2 a = M2 !a !a !a !a
  deriving Show

eagerMatrix :: Matrix2 Int
eagerMatrix = let x = product [1..] in M2 x x x x

data LazyMatrix2 a = LM2 a a a a
  deriving Show

lazyMatrix :: LazyMatrix2 Int
lazyMatrix = let x = product [1..] in LM2 x x x x

-- Вопросы

-- 1. Вам может понадобиться тип данных Pair с ручным управлением, первый компонент которого является строгим,
--    а второй - нет. Как бы вы это сделали?

data Pair a b = Pair !a b

-- 2. Что именно делает строгие и ленивые ByteStrings соответственно строгими и ленивыми?
--    Тот же вопрос относится и к Text. Ленивый вариант для обоих использует Chunk.
--    Можете ли вы сказать, что происходит, используя нашу интуицию для Data.ByteString.Lazy и Data.Text.Lazy?
--    Как это дает O(1) пространства при соответствующем использовании?

-- https://hackage.haskell.org/package/text-2.1/docs/src/Data.Text.Internal.Lazy.html#Text
-- data Text = Empty
--           | Chunk {-# UNPACK #-} !T.Text Text
--   deriving (Typeable)

-- T.Text из определения выше:
-- https://hackage.haskell.org/package/text-2.1/docs/src/Data.Text.Internal.html#Text
-- data Text = Text
--     {-# UNPACK #-} !A.Array -- ^ bytearray encoded as UTF-8
--     {-# UNPACK #-} !Int     -- ^ offset in bytes (not in Char!), pointing to a start of UTF-8 sequence
--     {-# UNPACK #-} !Int     -- ^ length in bytes (not in Char!), pointing to an end of UTF-8 sequence
--     deriving (Typeable)

-- Поле T.Text здесь ссылается на Data.Text.Internal.Text -- тип данных, представляющий собой
-- "компактный, неупакованный текстовый тип Unicode" -- это то, что представляет собой ваш обычный строгий тип Text.
-- Второе поле ссылается рекурсивно на тип, который мы определяем.
-- Это очень близко к обычному, строгому варианту списка (тому, что T.Text) с той лишь разницей,
-- что вычисление нового элемента списка происходит ровно в момент добавления этого элемента в список и не раньше.
-- Т.е. в момент, когда список в действительности будет создан в памяти.
-- Таким образом, мы оперируем списком строгих текстов.

-- Присмотревшись внимательнее, мы видим, что второе поле конструктора Chunk не является строгим.
-- Это означает, что мы не обязательно должны вычислять весь список, когда просто обращаемся к чанку.
-- Остальные элементы предоставляются по требованию, по мере необходимости, чанк за чанком.

-- Это дает частичный ответ на вопрос о пространстве O(1).
-- Мы можем заносить в память содержимое файла (например) чанк за чанком. При этом, если нам удастся
-- заставить сборщик мусора освобождать чанки после их использования, то в памяти одновременно будет
-- находиться всего лишь несколько чанков.
-- Именно эта задача решается с помощью библиотек потоковой передачи данных, таких как pipes, conduit или io-streams.

-------------------------------------------------------------------------------

-- {-# UNPACK #-} and unboxed strict fields

-- Распаковка строгих полей в типах данных -- одна из ключевых техник для написания эффективного кода на Haskell.
-- Какую задачу решает?

-- Лень реализуется путем хранения указателя на невычисленное выражение до тех пор, 
-- пока не потребуется фактический результат, после чего мы вычисляем выражение и 
-- заменяем указатель на него результатом

-- Напротив, небоксовое значение представлено в памяти только самим значением напрямую.
-- Перенаправление на значение не нужно, указателя на кучу тоже нет (и ленивости).
-- Например, Int - это тип boxed интов.
-- С другой стороны, Int# - это тип unboxed интов, представленных сырым машинным int, как в C
-- То же самое относится к Double#, Float#, Addr# (это просто void*) и т. д.

-- Важно, что такие типы не могут быть определены в Haskell: они реализованы в компиляторе.

-- Mы имеем доступ к исходным, низкоуровневым операциям через этот модуль GHC.Prim.
-- https://hackage.haskell.org/package/ghc-prim-0.11.0/docs/GHC-Prim.html

-- Как unboxed-типы относятся к прагме UNPACK?
-- Если я захочу хранить Double# прямо в матрице вместо Double, я могу написать так
-- (Важно, что использование прагмы UNPACK заставляет делать поля строгими, иначе UNPACK не будет работать)

data Mat2Bang = M2B {-# UNPACK #-} !Double
                    {-# UNPACK #-} !Double
                    {-# UNPACK #-} !Double
                    {-# UNPACK #-} !Double

-- Это эквивалентно следующей записи по своему смыслу
-- (чтобы этот синтакс работал, нужно подключить {-# LANGUAGE MagicHash #-})
data Mat2Hash = M2H Double#
                    Double#
                    Double#
                    Double#

-- Когда мы можем применять {-# UNPACK #-}?
-- Тип, который вы хотите распаковать, должен иметь единственный конструктор и не должен быть переменной типа.
-- Например, Maybe не подойдет из-за 2 конструкторов, а `data Foo a = Foo {-# UNPACK #-} !a` -- из-за переменной типа

-- Пример. У нас есть следующие типы. Как TwoSIPs будет представлен?

data StrictIntPair = SIP {-# UNPACK #-} !Int 
                         {-# UNPACK #-} !Int

data TwoSIPs = TwoSIPs {-# UNPACK #-} !StrictIntPair 
                       {-# UNPACK #-} !StrictIntPair

-- Ответ: data TwoSIPs = TwoSIPs Int# Int# Int# Int#

-------------------------------------------------------------------------------

-- $! and seq

-- Есть и другие способы контролировать вычисление.

-- Например, если вы хотите выичислить значение перед передачей его в функцию,
-- вы можете использовать `$!` -- строгую версию `$`, вычисляющую аргумент до WHNF перед передачей его в функцию

-- Еще один способ -- `seq`
-- https://hackage.haskell.org/package/ghc-prim-0.11.0/docs/GHC-Prim.html#v:seq
-- принимает 2 аргумента, вычисляет первый до WHNF и возвращает второй

-- Как использовать? пример с foldl'!
-- https://hackage.haskell.org/package/base-4.19.0.0/docs/src/Data.Foldable.html#foldl%27

-- Здесь есть следующий код: z `seq` k (f z x)
-- в этом случае первый аргумент `seq` -- z, и z будет вычислено до WHNF,
-- а затем он будет использоват при вычислении второго аргумента `seq` -- k (f z x)
-- второй же аргумент будет возвращен в качестве результата

-------------------------------------------------------------------------------

-- Безумно хорошая статья:
-- https://web.archive.org/web/20190313085409/https://alpmestan.com/posts/2013-10-02-oh-my-laziness.html

-------------------------------------------------------------------------------
